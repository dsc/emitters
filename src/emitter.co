{ eventsApi, triggerEvents, once,
} = require './emitter-helpers'



try
    {EventEmitter} = require 'events'
    EventEmitter.displayName or= 'EventEmitter'
    
    EventEmitter::trigger or= EventEmitter::emit
    EventEmitter::off     or= EventEmitter::removeListener
catch
    { toString:objToString, hasOwnProperty:own } = Object::
    isArray = Array.isArray or (o) -> objToString.call(o) is '[object Array]'
    ownKeys = Object.keys   or (o) -> k if own.call(o,k) for k in o
    
    
    /**
     * @class An event emitter.
     * 
     * Complies with most of the Node.js EventEmitter interface. Differences:
     *  - `on` and `once` both accept a context parameter, setting `this` for the callback.
     *  - `off` can filter on any/all of event name, callback, or context; `removeAllListeners` is just an alias.
     *  - Does not implement methods `listeners` or `setMaxListeners`, or the static method `EventEmitter.listenerCount`.
     *  - Does not email `newListener` or `removeListener` events.
     *  - Additional static method `decorate`, which adds 
     */
    class EventEmitter
        
        /**
         * Triggers an event.
         * 
         * @param {String} evt Event name(s) to trigger.
         * @param {*} ...args Additional arguments.
         * @returns {this} 
         */
        trigger: (evt) ->
            return this unless @_events
            
            args = [].slice.call arguments, 1
            return this unless eventsApi this, 'trigger', evt, args
            
            triggerEvents that, args        if @_events[evt]
            triggerEvents that, arguments   if @_events.all
            this
        
        emit: @::trigger
        
        
        on: (evt, fn, context) ->
            unless eventsApi(this, 'on', evt, [fn, context]) and fn
                return this
            
            evt = { fn, context, ctx:context or this }
            events = @_events or= {}
            unless events[evt]
                events[evt] = [evt]
            else
                # Copy now to avoid copying on emit (which is way more common)
                ( events[evt] = queue.slice() ).push evt
            
            this
        
        addListener: @::on
        
        
        once: (evt, fn, context) ->
            unless eventsApi(this, 'once', evt, [fn, context]) and fn
                return this
            
            self = this
            _once = once ->
                self.off evt, _once
                fn ...
            _once._callback = fn
            
            @on evt, context, _once
        
        
        off: (evt, fn, context) ->
            unless @_events and eventsApi(this, 'off', evt, [fn, context])
                return this
            unless evt or context or fn
                @_events = {}
                return this
            
            evts = if evt then [evt] else ownKeys @_events
            
            for evt of evts
                unless queue = @_events[evt]
                    continue
                unless fn or context
                    delete @_events[evt]
                    continue
                
                newQueue = @_events[evt] = []
                for evt of queue
                    if (fn and not (fn is evt.fn or fn is evt.fn._callback)) or (context and context is not evt.context)
                        newQueue.push evt
                delete @_events[evt] unless newQueue.length
            
            this
        
        removeListener     : @::off
        removeAllListeners : @::off
        
        
        listeners: (type) ->
            events = @_events or= {}
            queue  = events[type] or= []
            queue  = events[type] = [events[type]] unless isArray queue
            queue
        


### Static methods

EventEmitter import
    __emitter_methods__: <[ emit trigger on off addListener removeListener removeAllListeners once listeners ]>
    __class__: EventEmitter
    
    
    delegate: (target, source, methods) ->
        return target unless source and target
        proto    = @::
        methods ?= @__emitter_methods__
        for k of methods
            method = source[k] or proto[k]
            target[k] = method.bind source if typeof method is 'function'
        target
    
    
    decorate: (target, methods) ->
        proto    = @::
        methods ?= @__emitter_methods__
        for k of methods
            target[k] = proto[k]
        target
    
    
    # Coco metaprogramming hook
    extended: (SubClass) ->
        SuperClass = this
        
        for own k, v in SuperClass
            SubClass[k] = v unless SubClass[k]
        
        SubClass.__class__      = SubClass
        SubClass.__super__      = SuperClass::
        SubClass.__superclass__ = SuperClass
        
        SubClass
    



exports.EventEmitter = EventEmitter

