{ eventsApi, triggerEvents, once,
} = require './emitter-helpers'



try
    {EventEmitter} = require 'events'
    EventEmitter.displayName or= 'EventEmitter'
    
    EventEmitter::trigger or= EventEmitter::emit
    EventEmitter::off     or= EventEmitter::removeListener
catch
    { toString:objToString, hasOwnProperty:own } = Object::
    isArray = Array.isArray or (o) -> objToString.call(o) is '[object Array]'
    ownKeys = Object.keys   or (o) -> k if own.call(o,k) for k in o
    
    
    /**
     * @class An event emitter.
     * 
     * Complies with most of the Node.js EventEmitter interface. Differences:
     *  - `on` and `once` both accept a context parameter, setting `this` for the callback.
     *  - `off` can filter on any/all of event name, callback, or context; `removeAllListeners` is just an alias.
     *  - Does not implement methods `listeners` or `setMaxListeners`, or the static method `EventEmitter.listenerCount`.
     *  - Does not email `newListener` or `removeListener` events.
     *  - Additional static method `decorate`, which adds 
     */
    class EventEmitter
        
        /**
         * Triggers an event.
         * 
         * @param {String} name Name of the event to trigger.
         * @param {*} ...args Additional arguments.
         * @returns {this} 
         */
        trigger: (name) ->
            return this unless @_events
            
            args = [].slice.call arguments, 1
            return this unless eventsApi this, 'trigger', name, args
            
            triggerEvents that, args        if @_events[name]
            triggerEvents that, arguments   if @_events.all
            this
        
        emit: @::trigger
        
        
        on: (name, fn, context) ->
            unless eventsApi(this, 'on', name, [fn, context]) and fn
                return this
            
            evt = { fn, context, ctx:context or this }
            events = @_events or= {}
            unless events[name]
                events[name] = [evt]
            else
                # Copy now to avoid copying on emit (which is way more common)
                ( events[name] = queue.slice() ).push evt
            
            this
        
        addListener: @::on
        
        
        once: (name, fn, context) ->
            unless eventsApi(this, 'once', name, [fn, context]) and fn
                return this
            
            self = this
            _once = once ->
                self.off name, _once
                fn ...
            _once._callback = fn
            
            @on name, context, _once
        
        
        off: (name, fn, context) ->
            unless @_events and eventsApi(this, 'off', name, [fn, context])
                return this
            unless name or context or fn
                @_events = {}
                return this
            
            names = if name then [name] else ownKeys @_events
            
            for name of names
                unless queue = @_events[name]
                    continue
                unless fn or context
                    delete @_events[name]
                    continue
                
                newQueue = @_events[name] = []
                for evt of queue
                    if (fn and not (fn is evt.fn or fn is evt.fn._callback)) or (context and context is not evt.context)
                        newQueue.push evt
                delete @_events[name] unless newQueue.length
            
            this
        
        removeListener     : @::off
        removeAllListeners : @::off
        
        


### Static methods

EventEmitter import
    __emitter_methods__: <[ trigger emit on addListener once off removeListener removeAllListeners ]>
    
    
    delegate: (target, source, methods) ->
        return target unless source and target
        methods ?= @..__emitter_methods__
        EmitterProto = @::
        for k of methods
            method = source[k] or EmitterProto[k]
            target[k] = method.bind source if typeof method is 'function'
        target
    
    
    decorate: (target, methods) ->
        methods ?= @..__emitter_methods__
        EmitterProto = @::
        for k of methods
            target[k] = EmitterProto[k]
        target



exports.EventEmitter = EventEmitter

