{
  "version": 3,
  "file": "generated.js",
  "sources": [
    "/usr/local/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/Users/dsc/dev/projects/emitters/index.js",
    "/Users/dsc/dev/projects/emitters/lib/chained-emitter.js",
    "/Users/dsc/dev/projects/emitters/lib/emitter-helpers.js",
    "/Users/dsc/dev/projects/emitters/lib/emitter.js",
    "/Users/dsc/dev/projects/emitters/lib/ready-emitter.js",
    "/Users/dsc/dev/projects/emitters/lib/waiting-emitter.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/*\n *      emitters -- v0.2.0\n *      (c) 20.2.0014 David Schoonover <dsc@less.ly>\n *      emitters is freely distributable under the MIT license.\n *      \n *      For all details and documentation:\n *      https://github.com/dsc/emitters\n */\n\nexports.VERSION = '0.2.0';\n\nimport$(exports, require('./lib/emitter'));\nimport$(exports, require('./lib/chained-emitter'));\nimport$(exports, require('./lib/ready-emitter'));\nimport$(exports, require('./lib/waiting-emitter'));\n\nfunction import$(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}\n",
    "var EventEmitter, ChainedEmitter, out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice;\nEventEmitter = require('./emitter').EventEmitter;\n/**\n * @class An EventEmitter that re-dispatches events to its parent.\n * @extends EventEmitter\n */\nout$.ChainedEmitter = ChainedEmitter = (function(superclass){\n  ChainedEmitter.displayName = 'ChainedEmitter';\n  var prototype = extend$(ChainedEmitter, superclass).prototype, constructor = ChainedEmitter;\n  ChainedEmitter.__emitter_methods__ = EventEmitter.__emitter_methods__.concat(['parentEmitter']);\n  /**\n   * @constructor\n   * @param {EventEmitter} [parent] Our parent emitter for bubbling.\n   */\n  function ChainedEmitter(parent){\n    if (parent) {\n      this.parentEmitter(parent);\n    }\n  }\n  /**\n   * @returns {null|EventEmitter} Current parent emitter.\n   */\n  /**\n   * Setter for our parent emitter for bubbling.\n   * @param {EventEmitter} parent New parent emitter.\n   * @returns {this}\n   */\n  prototype.parentEmitter = function(parent){\n    if (parent == null) {\n      return this._parentEmitter;\n    }\n    this._parentEmitter = parent;\n    return this;\n  };\n  /**\n   * As EventEmitter::emit(), but patched to bubble to the\n   * parent emitter (if possible), provided the event handler \n   * does not stop propagation by returning `false`.\n   * \n   * @param {String} event Event to emit.\n   * @param {...Any} args Arguments to pass to the event handlers.\n   * @returns {Boolean} Whether propagation was stopped.\n   */\n  prototype.trigger = function(name){\n    var args, bubble, queue, i$, len$, listener, ref$, ok, ref1$;\n    args = slice$.call(arguments, 1);\n    bubble = true;\n    if (queue = (this._events || {})[name]) {\n      for (i$ = 0, len$ = queue.length; i$ < len$; ++i$) {\n        listener = queue[i$];\n        bubble = listener.apply(this, args) !== false && bubble;\n      }\n    }\n    if (bubble && typeof ((ref$ = this._parentEmitter) != null ? ref$.trigger : void 8) === 'function') {\n      ok = (ref1$ = this._parentEmitter).trigger.apply(ref1$, arguments) || !!queue;\n    }\n    return ok;\n  };\n  prototype.emit = ChainedEmitter.prototype.trigger;\n  return ChainedEmitter;\n}(EventEmitter));\nfunction extend$(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}",
    "/**\n * @private\n */\nvar EVENT_SEP, eventsApi, triggerEvents, once, out$ = typeof exports != 'undefined' && exports || this;\nEVENT_SEP = /\\s+/;\nout$.eventsApi = eventsApi = function(obj, action, names, rest){\n  var key, val, i$, ref$, len$, name;\n  if (!names) {\n    return true;\n  }\n  if (typeof names === 'object') {\n    for (key in names) {\n      val = names[key];\n      obj[action].apply(obj, [key, val].concat(rest));\n    }\n    return false;\n  }\n  if (EVENT_SEP.test(names)) {\n    for (i$ = 0, len$ = (ref$ = names.split(EVENT_SEP)).length; i$ < len$; ++i$) {\n      name = ref$[i$];\n      obj[action].apply(obj, [name].concat(rest));\n    }\n    return false;\n  }\n  return true;\n};\nout$.triggerEvents = triggerEvents = function(events, args){\n  var a1, a2, a3, i$, len$, ev, j$, len1$, k$, len2$, l$, len3$, m$, len4$;\n  a1 = args[0], a2 = args[1], a3 = args[2];\n  switch (args.length) {\n  case 0:\n    for (i$ = 0, len$ = events.length; i$ < len$; ++i$) {\n      ev = events[i$];\n      ev.callback.call(ev.ctx);\n    }\n    return;\n  case 1:\n    for (j$ = 0, len1$ = events.length; j$ < len1$; ++j$) {\n      ev = events[j$];\n      ev.callback.call(ev.ctx, a1);\n    }\n    return;\n  case 2:\n    for (k$ = 0, len2$ = events.length; k$ < len2$; ++k$) {\n      ev = events[k$];\n      ev.callback.call(ev.ctx, a1, a2);\n    }\n    return;\n  case 3:\n    for (l$ = 0, len3$ = events.length; l$ < len3$; ++l$) {\n      ev = events[l$];\n      ev.callback.call(ev.ctx, a1, a2, a3);\n    }\n    return;\n  default:\n    for (m$ = 0, len4$ = events.length; m$ < len4$; ++m$) {\n      ev = events[m$];\n      ev.callback.apply(ev.ctx, args);\n    }\n  }\n};\nout$.once = once = function(fn){\n  var ran, res;\n  return function(){\n    if (ran) {\n      return result;\n    }\n    ran = true;\n    res = fn.apply(this, arguments);\n    fn = null;\n    return result;\n  };\n};",
    "var ref$, eventsApi, triggerEvents, once, EventEmitter, ref1$, ref2$, e, ref3$, objToString, own, isArray, ownKeys;\nref$ = require('./emitter-helpers'), eventsApi = ref$.eventsApi, triggerEvents = ref$.triggerEvents, once = ref$.once;\ntry {\n  EventEmitter = require('events').EventEmitter;\n  EventEmitter.displayName || (EventEmitter.displayName = 'EventEmitter');\n  (ref1$ = EventEmitter.prototype).trigger || (ref1$.trigger = EventEmitter.prototype.emit);\n  (ref2$ = EventEmitter.prototype).off || (ref2$.off = EventEmitter.prototype.removeListener);\n} catch (e$) {\n  e = e$;\n  ref3$ = Object.prototype, objToString = ref3$.toString, own = ref3$.hasOwnProperty;\n  isArray = Array.isArray || function(o){\n    return objToString.call(o) === '[object Array]';\n  };\n  ownKeys = Object.keys || function(o){\n    var k, results$ = [];\n    for (k in o) {\n      if (own.call(o, k)) {\n        results$.push(k);\n      }\n    }\n    return results$;\n  };\n  /**\n   * @class An event emitter.\n   * \n   * Complies with most of the Node.js EventEmitter interface. Differences:\n   *  - `on` and `once` both accept a context parameter, setting `this` for the callback.\n   *  - `off` can filter on any/all of event name, callback, or context; `removeAllListeners` is just an alias.\n   *  - Does not implement methods `listeners` or `setMaxListeners`, or the static method `EventEmitter.listenerCount`.\n   *  - Does not email `newListener` or `removeListener` events.\n   *  - Additional static method `decorate`, which adds \n   */\n  EventEmitter = (function(){\n    EventEmitter.displayName = 'EventEmitter';\n    var prototype = EventEmitter.prototype, constructor = EventEmitter;\n    /**\n     * Triggers an event.\n     * \n     * @param {String} name Name of the event to trigger.\n     * @param {*} ...args Additional arguments.\n     * @returns {this} \n     */\n    prototype.trigger = function(name){\n      var args, that;\n      if (!this._events) {\n        return this;\n      }\n      args = [].slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) {\n        return this;\n      }\n      if (that = this._events[name]) {\n        triggerEvents(that, args);\n      }\n      if (that = this._events.all) {\n        triggerEvents(that, arguments);\n      }\n      return this;\n    };\n    prototype.emit = EventEmitter.prototype.trigger;\n    prototype.on = function(name, fn, context){\n      var evt, events;\n      if (!(eventsApi(this, 'on', name, [fn, context]) && fn)) {\n        return this;\n      }\n      evt = {\n        fn: fn,\n        context: context,\n        ctx: context || this\n      };\n      events = this._events || (this._events = {});\n      if (!events[name]) {\n        events[name] = [evt];\n      } else {\n        (events[name] = queue.slice()).push(evt);\n      }\n      return this;\n    };\n    prototype.addListener = EventEmitter.prototype.on;\n    prototype.once = function(name, fn, context){\n      var self, _once;\n      if (!(eventsApi(this, 'once', name, [fn, context]) && fn)) {\n        return this;\n      }\n      self = this;\n      _once = once(function(){\n        self.off(name, _once);\n        return fn.apply(this, arguments);\n      });\n      _once._callback = fn;\n      return this.on(name, context, _once);\n    };\n    prototype.off = function(name, fn, context){\n      var names, i$, len$, queue, newQueue, j$, len1$, evt;\n      if (!(this._events && eventsApi(this, 'off', name, [fn, context]))) {\n        return this;\n      }\n      if (!(name || context || fn)) {\n        this._events = {};\n        return this;\n      }\n      names = name\n        ? [name]\n        : ownKeys(this._events);\n      for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {\n        name = names[i$];\n        if (!(queue = this._events[name])) {\n          continue;\n        }\n        if (!(fn || context)) {\n          delete this._events[name];\n          continue;\n        }\n        newQueue = this._events[name] = [];\n        for (j$ = 0, len1$ = queue.length; j$ < len1$; ++j$) {\n          evt = queue[j$];\n          if ((fn && !(fn === evt.fn || fn === evt.fn._callback)) || (context && context !== evt.context)) {\n            newQueue.push(evt);\n          }\n        }\n        if (!newQueue.length) {\n          delete this._events[name];\n        }\n      }\n      return this;\n    };\n    prototype.removeListener = EventEmitter.prototype.off;\n    prototype.removeAllListeners = EventEmitter.prototype.off;\n    function EventEmitter(){}\n    return EventEmitter;\n  }());\n}\nEventEmitter.__emitter_methods__ = ['trigger', 'emit', 'on', 'addListener', 'once', 'off', 'removeListener', 'removeAllListeners'];\nEventEmitter.delegate = function(target, source, methods){\n  var EmitterProto, i$, len$, k, method;\n  if (!(source && target)) {\n    return target;\n  }\n  methods == null && (methods = this.constructor.__emitter_methods__);\n  EmitterProto = this.prototype;\n  for (i$ = 0, len$ = methods.length; i$ < len$; ++i$) {\n    k = methods[i$];\n    method = source[k] || EmitterProto[k];\n    if (typeof method === 'function') {\n      target[k] = method.bind(source);\n    }\n  }\n  return target;\n};\nEventEmitter.decorate = function(target, methods){\n  var EmitterProto, i$, len$, k;\n  methods == null && (methods = this.constructor.__emitter_methods__);\n  EmitterProto = this.prototype;\n  for (i$ = 0, len$ = methods.length; i$ < len$; ++i$) {\n    k = methods[i$];\n    target[k] = EmitterProto[k];\n  }\n  return target;\n};\nexports.EventEmitter = EventEmitter;",
    "var EventEmitter, ReadyEmitter, out$ = typeof exports != 'undefined' && exports || this;\nEventEmitter = require('./emitter').EventEmitter;\n/**\n * @class An EventEmitter that auto-triggers new handlers once \"ready\".\n * @extends EventEmitter\n */\nout$.ReadyEmitter = ReadyEmitter = (function(superclass){\n  ReadyEmitter.displayName = 'ReadyEmitter';\n  var prototype = extend$(ReadyEmitter, superclass).prototype, constructor = ReadyEmitter;\n  ReadyEmitter.__emitter_methods__ = EventEmitter.__emitter_methods__.concat(['ready']);\n  /**\n   * Whether this object is ready.\n   * @type Boolean\n   */\n  prototype._ready = false;\n  /**\n   * Name of the ready event.\n   * @type String\n   */\n  prototype.__ready_event__ = 'ready';\n  /**\n   * Getter for the ready state.\n   * @returns {Boolean} Whether the emitter is ready or not.\n   */\n  /**\n   * Registers a callback on ready; fired immediately if already ready.\n   * @param {Function} callback The callback.\n   * @returns {this}\n   */\n  /**\n   * Setter for the ready state.\n   * \n   * If truthy, this triggers the 'ready' event provided it has not yet been\n   * triggered, and subsequent listeners added to this event will be \n   * auto-triggered.\n   * \n   * If falsy, this resets the 'ready' event to its non-triggered state, firing a\n   * 'ready-reset' event.\n   * \n   * @param {Boolean} value Sets the ready state.\n   * @param {Boolean} [force=false] Trigger the event even if already ready.\n   * @returns {this}\n   */\n  prototype.ready = function(val, force){\n    var evt;\n    force == null && (force = false);\n    if (val == null) {\n      return !!this._ready;\n    }\n    if (typeof val === 'function') {\n      return this.on(this.__ready_event__, val);\n    }\n    val = !!val;\n    if (val === this._ready && !force) {\n      return this;\n    }\n    this._ready = val;\n    evt = this.__ready_event__;\n    if (!val) {\n      evt = evt + \"-reset\";\n    }\n    this.emit(evt, this);\n    return this;\n  };\n  /**\n   * Wrap {@link EventEmitter#on} registration to handle registrations\n   * on 'ready' after we've broadcast the event. Handler will always still\n   * be registered, however, in case the emitter is reset.\n   * \n   * @param {String} events Space-separated events for which to register.\n   * @param {Function} callback\n   * @returns {this}\n   */\n  prototype.on = function(events, callback){\n    var this$ = this;\n    superclass.prototype.on.apply(this, arguments);\n    if (this.ready() && events.split(/\\s+/).indexOf(this.__ready_event__) > -1) {\n      setTimeout(function(){\n        return callback.call(this$, this$);\n      });\n    }\n    return this;\n  };\n  prototype.addListener = ReadyEmitter.prototype.on;\n  function ReadyEmitter(){}\n  return ReadyEmitter;\n}(EventEmitter));\nfunction extend$(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}",
    "var EventEmitter, WaitingEmitter, out$ = typeof exports != 'undefined' && exports || this;\nEventEmitter = require('./emitter').EventEmitter;\n/**\n * @class An EventEmitter with a ratchet-up waiting counter.\n * @extends EventEmitter\n */\nout$.WaitingEmitter = WaitingEmitter = (function(superclass){\n  WaitingEmitter.displayName = 'WaitingEmitter';\n  var prototype = extend$(WaitingEmitter, superclass).prototype, constructor = WaitingEmitter;\n  WaitingEmitter.__emitter_methods__ = EventEmitter.__emitter_methods__.concat(['wait', 'unwait', 'unwaitAnd']);\n  /**\n   * Count of outstanding tasks.\n   * @type Number\n   */\n  prototype._waitingOn = 0;\n  /**\n   * Increment the waiting task counter.\n   * @returns {this}\n   */\n  prototype.wait = function(){\n    var count;\n    count = this._waitingOn || 0;\n    this._waitingOn += 1;\n    if (count === 0 && this._waitingOn > 0) {\n      this.trigger('start-waiting', this);\n    }\n    return this;\n  };\n  /**\n   * Decrement the waiting task counter.\n   * @returns {this}\n   */\n  prototype.unwait = function(){\n    var count;\n    count = this._waitingOn || 0;\n    this._waitingOn -= 1;\n    if (this._waitingOn === 0 && count > 0) {\n      this.trigger('stop-waiting', this);\n    }\n    return this;\n  };\n  /**\n   * @param {Function} fn Function to wrap.\n   * @returns {Function} A function wrapping the passed function with a call\n   *  to `unwait()`, then delegating with current context and arguments.\n   */\n  prototype.unwaitAnd = function(fn){\n    var self;\n    self = this;\n    return function(){\n      self.unwait();\n      return fn.apply(this, arguments);\n    };\n  };\n  function WaitingEmitter(){}\n  return WaitingEmitter;\n}(EventEmitter));\nfunction extend$(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}"
  ],
  "sourceRoot": ""
}