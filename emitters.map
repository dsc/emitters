{
  "version": 3,
  "file": "generated.js",
  "sources": [
    "/usr/local/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/Users/dsc/dev/projects/emitters/lib/chained-emitter.js",
    "/Users/dsc/dev/projects/emitters/lib/emitter-helpers.js",
    "/Users/dsc/dev/projects/emitters/lib/emitter.js",
    "/Users/dsc/dev/projects/emitters/lib/index.js",
    "/Users/dsc/dev/projects/emitters/lib/ready-emitter.js",
    "/Users/dsc/dev/projects/emitters/lib/utils.js",
    "/Users/dsc/dev/projects/emitters/lib/waiting-emitter.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var EventEmitter, ChainedEmitter, out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice;\nEventEmitter = require('./emitter').EventEmitter;\n/**\n * @class An EventEmitter that re-dispatches events to its parent.\n * @extends EventEmitter\n */\nout$.ChainedEmitter = ChainedEmitter = (function(superclass){\n  ChainedEmitter.displayName = 'ChainedEmitter';\n  var prototype = extend$(ChainedEmitter, superclass).prototype, constructor = ChainedEmitter;\n  ChainedEmitter.__emitter_methods__ = EventEmitter.__emitter_methods__.concat(['parentEmitter']);\n  /**\n   * @constructor\n   * @param {EventEmitter} [parent] Our parent emitter for bubbling.\n   */\n  function ChainedEmitter(parent){\n    if (parent) {\n      this.parentEmitter(parent);\n    }\n  }\n  /**\n   * @returns {null|EventEmitter} Current parent emitter.\n   */\n  /**\n   * Setter for our parent emitter for bubbling.\n   * @param {EventEmitter} parent New parent emitter.\n   * @returns {this}\n   */\n  prototype.parentEmitter = function(parent){\n    if (parent == null) {\n      return this._parentEmitter;\n    }\n    this._parentEmitter = parent;\n    return this;\n  };\n  /**\n   * As EventEmitter::emit(), but patched to bubble to the\n   * parent emitter (if possible), provided the event handler \n   * does not stop propagation by returning `false`.\n   * \n   * @param {String} event Event to emit.\n   * @param {...Any} args Arguments to pass to the event handlers.\n   * @returns {Boolean} Whether propagation was stopped.\n   */\n  prototype.trigger = function(name){\n    var args, bubble, queue, i$, len$, listener, ref$, ok, ref1$;\n    args = slice$.call(arguments, 1);\n    bubble = true;\n    if (queue = (this._events || {})[name]) {\n      for (i$ = 0, len$ = queue.length; i$ < len$; ++i$) {\n        listener = queue[i$];\n        bubble = listener.apply(this, args) !== false && bubble;\n      }\n    }\n    if (bubble && typeof ((ref$ = this._parentEmitter) != null ? ref$.trigger : void 8) === 'function') {\n      ok = (ref1$ = this._parentEmitter).trigger.apply(ref1$, arguments) || !!queue;\n    }\n    return ok;\n  };\n  prototype.emit = ChainedEmitter.prototype.trigger;\n  return ChainedEmitter;\n}(EventEmitter));\nfunction extend$(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}",
    "/**\n * @private\n */\nvar EVENT_SEP, out$ = typeof exports != 'undefined' && exports || this;\nEVENT_SEP = /\\s+/;\nout$.eventsApi = eventsApi;\nfunction eventsApi(obj, action, names, rest){\n  var key, val, i$, ref$, len$, name;\n  if (!names) {\n    return true;\n  }\n  if (typeof names === 'object') {\n    for (key in names) {\n      val = names[key];\n      obj[action].apply(obj, [key, val].concat(rest));\n    }\n    return false;\n  }\n  if (EVENT_SEP.test(names)) {\n    for (i$ = 0, len$ = (ref$ = names.split(EVENT_SEP)).length; i$ < len$; ++i$) {\n      name = ref$[i$];\n      obj[action].apply(obj, [name].concat(rest));\n    }\n    return false;\n  }\n  return true;\n}\nout$.triggerEvents = triggerEvents;\nfunction triggerEvents(events, args){\n  var i$, len$, ev, j$, len1$, k$, len2$, l$, len3$, m$, len4$, n$, len5$;\n  switch (args.length) {\n  case 0:\n    for (i$ = 0, len$ = events.length; i$ < len$; ++i$) {\n      ev = events[i$];\n      ev.callback.call(ev.ctx);\n    }\n    return;\n  case 1:\n    for (j$ = 0, len1$ = events.length; j$ < len1$; ++j$) {\n      ev = events[j$];\n      ev.callback.call(ev.ctx, a[0]);\n    }\n    return;\n  case 2:\n    for (k$ = 0, len2$ = events.length; k$ < len2$; ++k$) {\n      ev = events[k$];\n      ev.callback.call(ev.ctx, a[0], a[1]);\n    }\n    return;\n  case 3:\n    for (l$ = 0, len3$ = events.length; l$ < len3$; ++l$) {\n      ev = events[l$];\n      ev.callback.call(ev.ctx, a[0], a[1], a[2]);\n    }\n    return;\n  case 4:\n    for (m$ = 0, len4$ = events.length; m$ < len4$; ++m$) {\n      ev = events[m$];\n      ev.callback.call(ev.ctx, a[0], a[1], a[2], a[3]);\n    }\n    return;\n  default:\n    for (n$ = 0, len5$ = events.length; n$ < len5$; ++n$) {\n      ev = events[n$];\n      ev.callback.apply(ev.ctx, args);\n    }\n    return;\n  }\n}\nout$.once = once;\nfunction once(fn){\n  var ran, res;\n  return function(){\n    if (ran) {\n      return res;\n    }\n    ran = true;\n    res = fn.apply(this, arguments);\n    fn = null;\n    return res;\n  };\n}",
    "var ref$, eventsApi, triggerEvents, once, EventEmitter, ref1$, ref2$, e, ref3$, objToString, own, isArray, ownKeys, DEFAULT_EVENT_EMITTER_METHODS, out$ = typeof exports != 'undefined' && exports || this;\nref$ = require('./emitter-helpers'), eventsApi = ref$.eventsApi, triggerEvents = ref$.triggerEvents, once = ref$.once;\ntry {\n  EventEmitter = require('events').EventEmitter;\n  EventEmitter.displayName || (EventEmitter.displayName = 'EventEmitter');\n  (ref1$ = EventEmitter.prototype).trigger || (ref1$.trigger = EventEmitter.prototype.emit);\n  (ref2$ = EventEmitter.prototype).off || (ref2$.off = EventEmitter.prototype.removeListener);\n} catch (e$) {\n  e = e$;\n  ref3$ = Object.prototype, objToString = ref3$.toString, own = ref3$.hasOwnProperty;\n  isArray = Array.isArray || function(o){\n    return objToString.call(o) == '[object Array]';\n  };\n  ownKeys = Object.keys || function(o){\n    var k, results$ = [];\n    for (k in o) {\n      if (own.call(o, k)) {\n        results$.push(k);\n      }\n    }\n    return results$;\n  };\n  /**\n   * @class An event emitter.\n   * \n   * Complies with most of the Node.js EventEmitter interface. Differences:\n   *  - `on` and `once` both accept a context parameter, setting `this` for the callback.\n   *  - `off` can filter on any/all of event name, callback, or context; `removeAllListeners` is just an alias.\n   *  - Does not warn on max listeners (and `setMaxListeners()` just logs to console).\n   *  - Does not emit `newListener` or `removeListener` events.\n   *  - Additional static methods `delegate`, and `decorate` which adds \n   */\n  EventEmitter = (function(){\n    EventEmitter.displayName = 'EventEmitter';\n    var prototype = EventEmitter.prototype, constructor = EventEmitter;\n    /**\n     * Triggers an event.\n     * \n     * @param {String} evt Event name(s) to trigger.\n     * @param {*} ...args Additional arguments.\n     * @returns {this}\n     * @alias trigger\n     */\n    prototype.emit = function(evt){\n      var args, that;\n      if (!this._events) {\n        return this;\n      }\n      args = [].slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', evt, args)) {\n        return this;\n      }\n      if (that = this._events[evt]) {\n        triggerEvents(that, args);\n      }\n      if (that = this._events.all) {\n        triggerEvents(that, arguments);\n      }\n      return this;\n    };\n    prototype.trigger = EventEmitter.prototype.emit;\n    prototype.on = function(evt, fn, thisArg){\n      var events;\n      if (!(eventsApi(this, 'on', evt, [fn, thisArg]) && fn)) {\n        return this;\n      }\n      evt = {\n        fn: fn,\n        thisArg: thisArg,\n        ctx: thisArg || this\n      };\n      events = this._events || (this._events = {});\n      if (!events[evt]) {\n        events[evt] = [evt];\n      } else {\n        (events[evt] = queue.slice()).push(evt);\n      }\n      return this;\n    };\n    prototype.addListener = EventEmitter.prototype.on;\n    prototype.once = function(evt, fn, thisArg){\n      var self, _once;\n      if (!(eventsApi(this, 'once', evt, [fn, thisArg]) && fn)) {\n        return this;\n      }\n      self = this;\n      _once = once(function(){\n        self.off(evt, _once);\n        return fn.apply(this, arguments);\n      });\n      _once.listener = fn;\n      return this.on(evt, thisArg, _once);\n    };\n    prototype.off = function(evt, fn, thisArg){\n      var evts, i$, len$, queue, newQueue, j$, len1$;\n      if (!(this._events && eventsApi(this, 'off', evt, [fn, thisArg]))) {\n        return this;\n      }\n      if (!(evt || thisArg || fn)) {\n        this._events = {};\n        return this;\n      }\n      evts = evt\n        ? [evt]\n        : ownKeys(this._events);\n      for (i$ = 0, len$ = evts.length; i$ < len$; ++i$) {\n        evt = evts[i$];\n        if (!(queue = this._events[evt])) {\n          continue;\n        }\n        if (!(fn || thisArg)) {\n          delete this._events[evt];\n          continue;\n        }\n        newQueue = this._events[evt] = [];\n        for (j$ = 0, len1$ = queue.length; j$ < len1$; ++j$) {\n          evt = queue[j$];\n          if ((fn && !(fn === evt.fn || fn === evt.fn.listener)) || (thisArg && thisArg !== evt.thisArg)) {\n            newQueue.push(evt);\n          }\n        }\n        if (!newQueue.length) {\n          delete this._events[evt];\n        }\n      }\n      return this;\n    };\n    prototype.removeListener = EventEmitter.prototype.off;\n    prototype.removeAllListeners = EventEmitter.prototype.off;\n    prototype.listeners = function(type){\n      var queue, ref$;\n      queue = ((ref$ = this._events) != null ? ref$[type] : void 8) || [];\n      if (!isArray(queue)) {\n        queue = events[type] = [events[type]];\n      }\n      return queue;\n    };\n    prototype.setMaxListeners = function(n){\n      return console.warn(\"EventEmitter::setMaxListeners() is unsupported!\");\n    };\n    /**\n     * @static\n     * @param {EventEmitter} emitter\n     * @param {String} evt\n     * @returns {Number} The number of listeners on an emitter for a given event.\n     */;\n    EventEmitter.listenerCount = function(emitter, evt){\n      var ref$, ref1$;\n      return (emitter != null ? (ref$ = emitter._events) != null ? (ref1$ = ref$[evt]) != null ? ref1$.length : void 8 : void 8 : void 8) || 0;\n    };\n    function EventEmitter(){}\n    return EventEmitter;\n  }());\n}\n/**\n * List of method names used by `delegate` and `decorate` when \n * @type String[]\n */\nout$.DEFAULT_EVENT_EMITTER_METHODS = DEFAULT_EVENT_EMITTER_METHODS = ['emit', 'trigger', 'on', 'off', 'addListener', 'removeListener', 'removeAllListeners', 'once', 'listeners'];\n/**\n * EventEmitter static methods.\n */\nEventEmitter.__emitter_methods__ = DEFAULT_EVENT_EMITTER_METHODS;\nEventEmitter.__class__ = EventEmitter;\n/**\n * Copies methods from a given source EventEmitter onto a target object,\n * binding them to the original emitter. This allows the target to masquerade\n * as the emitter, or for several objects to share an emitter.\n * \n * @static\n * @param {EventEmitter} source EventEmitter to borrow methods from.\n * @param {Object} target Object to attach methods to.\n * @param {String[]} [methods] List of method names to copy. Defaults\n *  to `__emitter_methods__` on the calling class, or failing\n *  that, `DEFAULT_EVENT_EMITTER_METHODS`.\n * @returns {Object} Target object.\n */\nEventEmitter.delegate = function(source, target, methods){\n  var proto, i$, len$, k, method;\n  if (!(source && target)) {\n    return target;\n  }\n  proto = this.prototype;\n  methods == null && (methods = this.__emitter_methods__ || DEFAULT_EVENT_EMITTER_METHODS);\n  for (i$ = 0, len$ = methods.length; i$ < len$; ++i$) {\n    k = methods[i$];\n    method = source[k] || proto[k];\n    if (typeof method === 'function') {\n      target[k] = method.bind(source);\n    }\n  }\n  return target;\n};\n/**\n * Mixes methods from an EventEmitter class into the target object.\n * \n * @static\n * @param {Object} target Object to mix methods into.\n * @param {String[]} [methods] List of method names to copy. Defaults\n *  to `__emitter_methods__` on the calling class, or failing\n *  that, `DEFAULT_EVENT_EMITTER_METHODS`.\n * @returns {Object} Target object.\n */\nEventEmitter.decorate = function(target, methods){\n  var proto, i$, len$, k;\n  proto = this.prototype;\n  methods == null && (methods = this.__emitter_methods__ || DEFAULT_EVENT_EMITTER_METHODS);\n  for (i$ = 0, len$ = methods.length; i$ < len$; ++i$) {\n    k = methods[i$];\n    target[k] = proto[k];\n  }\n  return target;\n};\n/**\n * Coco metaprogramming hook, called whenever the Class is extended.\n * \n * @private\n * @static\n * @param {Class} SubClass\n * @returns {Class} The Subclass.\n */\nEventEmitter.extended = function(SubClass){\n  var SuperClass, k, v, own$ = {}.hasOwnProperty;\n  SuperClass = this;\n  for (k in SuperClass) if (own$.call(SuperClass, k)) {\n    v = SuperClass[k];\n    if (!SubClass[k]) {\n      SubClass[k] = v;\n    }\n  }\n  SubClass.__class__ = SubClass;\n  SubClass.__super__ = SuperClass.prototype;\n  SubClass.__superclass__ = SuperClass;\n  return SubClass;\n};\nexports.EventEmitter = EventEmitter;",
    "exports.VERSION = '0.2.1';\nimport$(exports, require('./emitter'));\nimport$(exports, require('./chained-emitter'));\nimport$(exports, require('./ready-emitter'));\nimport$(exports, require('./waiting-emitter'));\nimport$(exports, require('./utils'));\nexports.helpers = require('./emitter-helpers');\nfunction import$(obj, src) {\n  var own = {}.hasOwnProperty;\n  for (var key in src)\n    if (own.call(src, key))\n      obj[key] = src[key];\n  return obj;\n}",
    "var EventEmitter, ReadyEmitter, out$ = typeof exports != 'undefined' && exports || this;\nEventEmitter = require('./emitter').EventEmitter;\n/**\n * @class An EventEmitter that auto-triggers new handlers once \"ready\".\n * @extends EventEmitter\n */\nout$.ReadyEmitter = ReadyEmitter = (function(superclass){\n  ReadyEmitter.displayName = 'ReadyEmitter';\n  var prototype = extend$(ReadyEmitter, superclass).prototype, constructor = ReadyEmitter;\n  ReadyEmitter.__emitter_methods__ = EventEmitter.__emitter_methods__.concat(['ready']);\n  /**\n   * Whether this object is ready.\n   * @type Boolean\n   */\n  prototype._ready = false;\n  /**\n   * Name of the ready event.\n   * @type String\n   */\n  prototype.__ready_event__ = 'ready';\n  /**\n   * Getter for the ready state.\n   * @returns {Boolean} Whether the emitter is ready or not.\n   */\n  /**\n   * Registers a callback on ready; fired immediately if already ready.\n   * @param {Function} callback The callback.\n   * @returns {this}\n   */\n  /**\n   * Setter for the ready state.\n   * \n   * If truthy, this triggers the 'ready' event provided it has not yet been\n   * triggered, and subsequent listeners added to this event will be \n   * auto-triggered.\n   * \n   * If falsy, this resets the 'ready' event to its non-triggered state, firing a\n   * 'ready-reset' event.\n   * \n   * @param {Boolean} value Sets the ready state.\n   * @param {Boolean} [force=false] Trigger the event even if already ready.\n   * @returns {this}\n   */\n  prototype.ready = function(val, force){\n    var event;\n    force == null && (force = false);\n    if (val == null) {\n      return !!this._ready;\n    }\n    event = this.__ready_event__ || 'ready';\n    if (typeof val == 'function') {\n      return this.on(event, val);\n    }\n    val = !!val;\n    if (val == this._ready && !force) {\n      return this;\n    }\n    this._ready = val;\n    if (!val) {\n      event = event + \"-reset\";\n    }\n    this.emit(event, this);\n    return this;\n  };\n  /**\n   * Wrap {@link EventEmitter#on} registration to handle registrations\n   * on 'ready' after we've broadcast the event. Handler will always still\n   * be registered, however, in case the emitter is reset.\n   * \n   * @param {String} events Space-separated events for which to register.\n   * @param {Function} callback\n   * @returns {this}\n   */\n  prototype.on = function(events, callback){\n    var event, this$ = this;\n    superclass.prototype.on.apply(this, arguments);\n    event = this.__ready_event__ || 'ready';\n    if (this.ready() && events.split(/\\s+/).indexOf(event) > -1) {\n      setTimeout(function(){\n        return callback.call(this$, this$);\n      });\n    }\n    return this;\n  };\n  prototype.addListener = ReadyEmitter.prototype.on;\n  function ReadyEmitter(){}\n  return ReadyEmitter;\n}(EventEmitter));\nfunction extend$(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}",
    "/**\n * Returns a function which triggers the given event.\n * \n * @param {EventEmitter} emitter Emitter to trigger.\n * @param {String} event Event to emit.\n * @param {*...} [data] Optional data.\n * @returns {Function}\n */\nvar out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice;\nout$.emitEvent = emitEvent;\nfunction emitEvent(emitter){\n  var data;\n  data = slice$.call(arguments, 1);\n  if (typeof (emitter != null ? emitter.emit : void 8) != 'function') {\n    throw TypeError;\n  }\n  return function(){\n    emitter.emit.apply(emitter, data);\n  };\n}\n/**\n * Sets up two emitters so events fired by one are redispatched by the other\n * (passing along event data).\n * \n * @param {EventEmitter} fromEmitter Source emitter for events.\n * @param {EventEmitter} toEmitter Emitter to repeat the events.\n * @param {String} [event='all'] Event to listen for redispatch.\n * @returns {Function} The redispach handler function (so you can unhook if necessary).\n */\nout$.redispatch = redispatch;\nfunction redispatch(fromEmitter, toEmitter, event){\n  var handler;\n  event == null && (event = 'all');\n  if (!(typeof (fromEmitter != null ? fromEmitter.on : void 8) == 'function' && typeof (toEmitter != null ? toEmitter.emit : void 8) == 'function')) {\n    throw TypeError;\n  }\n  handler = function(){\n    toEmitter.emit.apply(toEmitter, arguments);\n  };\n  fromEmitter.on(event, handler);\n  return handler;\n}",
    "var EventEmitter, WaitingEmitter, out$ = typeof exports != 'undefined' && exports || this;\nEventEmitter = require('./emitter').EventEmitter;\n/**\n * @class An EventEmitter with a ratchet-up waiting counter.\n * @extends EventEmitter\n */\nout$.WaitingEmitter = WaitingEmitter = (function(superclass){\n  WaitingEmitter.displayName = 'WaitingEmitter';\n  var prototype = extend$(WaitingEmitter, superclass).prototype, constructor = WaitingEmitter;\n  WaitingEmitter.__emitter_methods__ = EventEmitter.__emitter_methods__.concat(['waitingOn', 'wait', 'unwait', 'unwaitAnd']);\n  /**\n   * Count of outstanding tasks.\n   * @type Number\n   * @protected\n   */\n  prototype._waitingOn = 0;\n  /**\n   * @returns {Number} Count of outstanding tasks.\n   */\n  prototype.waitingOn = function(){\n    return this._waitingOn || 0;\n  };\n  /**\n   * Increment the waiting task counter.\n   * @returns {this}\n   */\n  prototype.wait = function(){\n    var count;\n    count = this._waitingOn || 0;\n    this._waitingOn += 1;\n    if (count === 0 && this._waitingOn > 0) {\n      this.trigger('start-waiting', this);\n    }\n    return this;\n  };\n  /**\n   * Decrement the waiting task counter.\n   * @returns {this}\n   */\n  prototype.unwait = function(){\n    var count;\n    count = this._waitingOn || 0;\n    this._waitingOn -= 1;\n    if (this._waitingOn === 0 && count > 0) {\n      this.trigger('stop-waiting', this);\n    }\n    return this;\n  };\n  /**\n   * @param {Function} fn Function to wrap.\n   * @param {Object} [thisArg] Optional context object to bind to fn.\n   * @returns {Function} A function wrapping the passed function with a call\n   *  to `unwait()`, then delegating with current context and arguments.\n   */\n  prototype.unwaitAnd = function(fn, thisArg){\n    var self;\n    self = this;\n    return function(){\n      var thisArg;\n      self.unwait();\n      thisArg == null && (thisArg = this);\n      return fn.apply(thisArg, arguments);\n    };\n  };\n  function WaitingEmitter(){}\n  return WaitingEmitter;\n}(EventEmitter));\nfunction extend$(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}"
  ],
  "sourceRoot": ""
}